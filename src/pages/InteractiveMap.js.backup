import React, { useEffect, useState, useCallback, useMemo, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";

import { MapContainer, TileLayer, Marker, Popup, useMapEvents, Circle, useMap, LayersControl } from "react-leaflet";
import "leaflet/dist/leaflet.css";
import "../styles/pages/globe-memories-interactive-map.css";
import "../styles/components/cinematic.css";
import travels from "../data/travelsData";
import L from "leaflet";
import debounce from "lodash/debounce";
import GlobeMemoriesCinematic from "../components/GlobeMemoriesCinematic";

import { useNavigate } from "react-router-dom";
import Toast from '../components/Toast';
import { useAuth } from '../context/AuthContext';

// Corrige o probleaflet-left .leaflet-controlma de √≠cones padr√£o no Leaflet com React
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png",
  iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",
  shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
});

// Criar √≠cones customizados modernos
const createCustomIcon = (color, iconType = 'location') => {
  const svgIcon = `
    <svg width="30" height="40" viewBox="0 0 30 40" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
          <feDropShadow dx="2" dy="4" stdDeviation="3" flood-opacity="0.3"/>
        </filter>
      </defs>
      <path d="M15 2c-7.168 0-13 5.832-13 13 0 8.284 13 23 13 23s13-14.716 13-23c0-7.168-5.832-13-13-13z" 
            fill="${color}" 
            stroke="white" 
            stroke-width="2" 
            filter="url(#shadow)"/>
      <circle cx="15" cy="15" r="6" fill="white"/>
      <text x="15" y="20" text-anchor="middle" fill="${color}" font-size="10" font-weight="bold">
        ${iconType === 'visited' ? '‚úì' : iconType === 'future' ? '‚ö°' : iconType === 'following' ? 'üë•' : iconType === 'public' ? 'üåç' : 'üìç'}
      </text>
    </svg>
  `;
  
  return new L.DivIcon({
    html: svgIcon,
    className: 'gm-map-custom-marker',
    iconSize: [30, 40],
    iconAnchor: [15, 40],
    popupAnchor: [0, -40],
  });
};

// Criar √≠cone do utilizador lan√ßador com imagem de perfil
const createUserLauncherIcon = (user, phase = 'idle') => {
  const userImage = user?.profileImage || user?.avatar || 'https://via.placeholder.com/60x60/ff6b35/white?text=üë§';
  const userName = user?.username || user?.name || 'Tu';
  
  const isThrowingPose = phase === 'throwing';
  const actionText = phase === 'preparing' ? 'Preparando...' : 
                    phase === 'throwing' ? 'ATIRANDO!' : 
                    'Pronto!';
  
  const launcherHtml = `
    <div style="
      width: 90px; 
      height: 100px; 
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      ${isThrowingPose ? 'transform: rotate(-15deg);' : ''}
      ${phase === 'preparing' ? 'animation: userBob 1s ease-in-out infinite;' : ''}
      ${phase === 'throwing' ? 'animation: userThrow 0.6s ease-out;' : ''}
    ">
      <!-- Avatar do utilizador -->
      <div style="
        width: 60px; 
        height: 60px; 
        border-radius: 50%;
        border: 3px solid #ff6b35;
        overflow: hidden;
        background: white;
        box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
        position: relative;
      ">
        <img src="${userImage}" 
             alt="${userName}" 
             style="
               width: 100%; 
               height: 100%; 
               object-fit: cover;
               ${isThrowingPose ? 'transform: scale(1.1) rotate(-5deg);' : ''}
             "
             onload="this.style.display='block';"
             onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
        />
        <div style="
          display: none;
          width: 100%; 
          height: 100%; 
          background: linear-gradient(135deg, #ff6b35, #ffa726);
          color: white;
          align-items: center;
          justify-content: center;
          font-size: 28px;
          position: absolute;
          top: 0;
          left: 0;
        ">${isThrowingPose ? 'ü§æ‚Äç‚ôÇÔ∏è' : 'üßô‚Äç‚ôÇÔ∏è'}</div>
      </div>
      
      <!-- Emoji da seta quando a atira -->
      ${isThrowingPose ? `
        <div style="
          position: absolute;
          top: 10px;
          right: -10px;
          font-size: 20px;
          animation: arrowLaunch 0.6s ease-out;
        ">üéØ</div>
      ` : ''}
      
      <!-- Nome e a√ß√£o -->
      <div style="
        margin-top: 5px;
        text-align: center;
        background: rgba(255, 255, 255, 0.9);
        padding: 2px 8px;
        border-radius: 12px;
        border: 1px solid #ff6b35;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      ">
        <div style="font-size: 10px; font-weight: bold; color: #333;">${userName}</div>
        <div style="font-size: 9px; color: #ff6b35; font-weight: bold;">${actionText}</div>
      </div>
    </div>
    
    <style>
      @keyframes userBob {
        0%, 100% { transform: translateY(0) rotate(0deg); }
        50% { transform: translateY(-3px) rotate(2deg); }
      }
      @keyframes userThrow {
        0% { transform: rotate(0deg) scale(1); }
        30% { transform: rotate(-10deg) scale(1.05); }
        60% { transform: rotate(-20deg) scale(1.1); }
        100% { transform: rotate(-15deg) scale(1); }
      }
      @keyframes arrowLaunch {
        0% { 
          transform: translateX(0) translateY(0) rotate(0deg) scale(1); 
          opacity: 1; 
        }
        20% { 
          transform: translateX(10px) translateY(-5px) rotate(15deg) scale(1.2); 
          opacity: 1; 
        }
        100% { 
          transform: translateX(60px) translateY(-30px) rotate(45deg) scale(0.8); 
          opacity: 0; 
        }
      }
    </style>
  `;
  
  return new L.DivIcon({
    html: launcherHtml,
    className: `gm-map-user-launcher ${phase}`,
    iconSize: [90, 100],
    iconAnchor: [45, 50],
    popupAnchor: [0, -50],
  });
};

// üéà BAL√ÉO DE AR QUENTE CINEMATOGR√ÅFICO
const BalloonComponent = ({ user, onLaunchArrow }) => {
  const userImage = user?.profileImage || user?.avatar;
  const userName = user?.username || user?.name || 'Aventureiro';

  return (
    <motion.div
      className="cinematic-balloon"
      initial={{ opacity: 0, y: -200, scale: 0.5 }}
      animate={{ 
        opacity: 1, 
        y: [-10, 10, -10], 
        scale: 1,
        rotate: [-2, 2, -2]
      }}
      transition={{ 
        opacity: { duration: 1 },
        y: { repeat: Infinity, duration: 4, ease: "easeInOut" },
        scale: { duration: 1 },
        rotate: { repeat: Infinity, duration: 6, ease: "easeInOut" }
      }}
      style={{
        position: 'absolute',
        top: '20%',
        left: '50%',
        transform: 'translateX(-50%)',
        cursor: 'pointer',
        pointerEvents: 'auto'
      }}
      onClick={onLaunchArrow}
    >
      <svg width="200" height="280" viewBox="0 0 200 280">
        <defs>
          <linearGradient id="balloonGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#ff6b35" />
            <stop offset="50%" stopColor="#f7931e" />
            <stop offset="100%" stopColor="#ffd700" />
          </linearGradient>
          <filter id="balloonShadow">
            <feDropShadow dx="4" dy="8" stdDeviation="6" floodOpacity="0.3"/>
          </filter>
        </defs>
        
        {/* Bal√£o */}
        <ellipse cx="100" cy="80" rx="60" ry="75" 
                 fill="url(#balloonGradient)" 
                 filter="url(#balloonShadow)"
                 stroke="#ff4500" 
                 strokeWidth="2"/>
        
        {/* Logo Globe Memories */}
        <text x="100" y="70" textAnchor="middle" 
              fontSize="12" fontWeight="bold" fill="white" 
              textShadow="1px 1px 2px rgba(0,0,0,0.5)">
          Globe
        </text>
        <text x="100" y="85" textAnchor="middle" 
              fontSize="12" fontWeight="bold" fill="white"
              textShadow="1px 1px 2px rgba(0,0,0,0.5)">
          Memories
        </text>
        
        {/* Cordas */}
        <line x1="70" y1="150" x2="85" y2="180" stroke="#8b4513" strokeWidth="2"/>
        <line x1="130" y1="150" x2="115" y2="180" stroke="#8b4513" strokeWidth="2"/>
        <line x1="100" y1="155" x2="100" y2="180" stroke="#8b4513" strokeWidth="2"/>
        
        {/* Cesto */}
        <rect x="80" y="180" width="40" height="30" 
              fill="#d2691e" stroke="#8b4513" strokeWidth="2" rx="5"/>
        
        {/* Avatar do utilizador no cesto */}
        <clipPath id="avatarClip">
          <circle cx="100" cy="195" r="15"/>
        </clipPath>
        
        {userImage ? (
          <image x="85" y="180" width="30" height="30" 
                 href={userImage} clipPath="url(#avatarClip)"/>
        ) : (
          <circle cx="100" cy="195" r="15" fill="#ff6b35"/>
        )}
        
        {/* Bra√ßo atirando */}
        <motion.g
          animate={{ rotate: [0, -30, 0] }}
          transition={{ repeat: Infinity, duration: 2, ease: "easeInOut" }}
          style={{ originX: "100px", originY: "190px" }}
        >
          <line x1="100" y1="190" x2="120" y2="175" 
                stroke="#fdbcb4" strokeWidth="4" strokeLinecap="round"/>
        </motion.g>
      </svg>
      
      {/* Tooltip */}
      <div className="balloon-tooltip">
        <p>üéØ Clica para {userName} atirar a seta m√°gica!</p>
      </div>
    </motion.div>
  );
};

// üèπ SETA ANIMADA CINEMATOGR√ÅFICA
const ArrowComponent = ({ startX, startY, targetX, targetY, onComplete }) => {
  return (
    <motion.div
      className="cinematic-arrow"
      initial={{ x: startX, y: startY, scale: 1, rotate: 0 }}
      animate={{ 
        x: targetX, 
        y: targetY,
        rotate: Math.atan2(targetY - startY, targetX - startX) * 180 / Math.PI
      }}
      transition={{ 
        duration: 1.5, 
        ease: "easeInOut",
        type: "spring",
        damping: 12
      }}
      onAnimationComplete={onComplete}
      style={{
        position: 'absolute',
        pointerEvents: 'none'
      }}
    >
      <svg width="40" height="8" viewBox="0 0 40 8">
        <defs>
          <linearGradient id="arrowGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stopColor="white" />
            <stop offset="100%" stopColor="#ffd700" />
          </linearGradient>
        </defs>
        <path d="M0 4 L30 4 M25 1 L30 4 L25 7" 
              stroke="url(#arrowGrad)" 
              strokeWidth="3" 
              fill="none"
              strokeLinecap="round"
              filter="drop-shadow(0 0 6px rgba(255,255,255,0.8))"/>
        
        {/* Rastro branco */}
        <motion.path
          d="M0 4 L-20 4"
          stroke="rgba(255,255,255,0.6)"
          strokeWidth="2"
          initial={{ pathLength: 0 }}
          animate={{ pathLength: 1 }}
          transition={{ duration: 0.8, ease: "easeOut" }}
        />
      </svg>
    </motion.div>
  );
};

// ‚úàÔ∏è AVI√ÉO 3D CINEMATOGR√ÅFICO
const PlaneComponent = ({ path, onComplete }) => {
  return (
    <motion.div
      className="cinematic-plane"
      style={{
        position: 'absolute',
        pointerEvents: 'none'
      }}
    >
      <motion.div
        animate={{ 
          x: path.map(p => p.x),
          y: path.map(p => p.y),
          rotate: path.map(p => p.rotation || 0)
        }}
        transition={{ 
          duration: 3,
          ease: "easeInOut",
          times: path.map((_, i) => i / (path.length - 1))
        }}
        onAnimationComplete={onComplete}
      >
        <svg width="60" height="30" viewBox="0 0 60 30">
          <defs>
            <linearGradient id="planeGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stopColor="#e8f4fd" />
              <stop offset="50%" stopColor="#b3d9ff" />
              <stop offset="100%" stopColor="#7bb3f0" />
            </linearGradient>
            <filter id="planeShadow">
              <feDropShadow dx="2" dy="4" stdDeviation="3" floodOpacity="0.4"/>
            </filter>
          </defs>
          
          {/* Fuselagem */}
          <ellipse cx="30" cy="15" rx="25" ry="6" 
                   fill="url(#planeGrad)" 
                   filter="url(#planeShadow)"/>
          
          {/* Asas */}
          <ellipse cx="20" cy="15" rx="8" ry="12" fill="#a8d0f0"/>
          
          {/* Cauda */}
          <path d="M5 15 L15 10 L15 20 Z" fill="#7bb3f0"/>
          
          {/* Janelas */}
          <circle cx="35" cy="13" r="2" fill="#87ceeb" opacity="0.7"/>
          <circle cx="30" cy="13" r="2" fill="#87ceeb" opacity="0.7"/>
          <circle cx="25" cy="13" r="2" fill="#87ceeb" opacity="0.7"/>
        </svg>
        
        {/* Rastro de fumo */}
        <motion.div
          className="plane-trail"
          initial={{ width: 0, opacity: 0 }}
          animate={{ width: 100, opacity: [0, 0.6, 0] }}
          transition={{ duration: 1, repeat: Infinity, ease: "easeOut" }}
          style={{
            position: 'absolute',
            top: '50%',
            left: '-100px',
            height: '3px',
            background: 'linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent)',
            transform: 'translateY(-50%)'
          }}
        />
      </motion.div>
    </motion.div>
  );
};

// ‚ú® NOVA SETA TRACEJADA BRANCA COM PART√çCULAS ‚ú®
const createWhiteDashedArrow = (progress = 0, rotation = 0) => {
  const arrowHtml = `
    <div style="
      width: 80px; 
      height: 80px; 
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transform: rotate(${rotation}deg);
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
    ">
      <!-- Seta SVG Tracejada Branca -->
      <svg width="60" height="60" viewBox="0 0 60 60" style="position: absolute;">
        <defs>
          <linearGradient id="arrowGradient" x1="0%" y1="0%"x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#ffffff;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#f0f0f0;stop-opacity:0.9" />
            <stop offset="100%" style="stop-color:#ffffff;stop-opacity:1" />
          </linearGradient>
        </defs>
        <!-- Corpo da seta -->
        <path d="M10 30 L40 30 M35 25 L40 30 L35 35" 
              stroke="url(#arrowGradient)" 
              stroke-width="3" 
              stroke-dasharray="6,3" 
              fill="none"
              stroke-linecap="round"
              stroke-linejoin="round">
          <animate attributeName="stroke-dashoffset" 
                   values="0;-9;0" 
                   dur="1.5s" 
                   repeatCount="indefinite"/>
        </path>
      </svg>
      
      <!-- Part√≠culas Luminosas -->
      <div class="particle particle-1" style="
        position: absolute;
        width: 4px;
        height: 4px;
        background: white;
        border-radius: 50%;
        box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
        animation: particle1 2s ease-in-out infinite;
      "></div>
      <div class="particle particle-2" style="
        position: absolute;
        width: 3px;
        height: 3px;
        background: white;
        border-radius: 50%;
        box-shadow: 0 0 4px rgba(255, 255, 255, 0.6);
        animation: particle2 1.8s ease-in-out infinite 0.3s;
      "></div>
      <div class="particle particle-3" style="
        position: absolute;
        width: 2px;
        height: 2px;
        background: white;
        border-radius: 50%;
        box-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
        animation: particle3 2.2s ease-in-out infinite 0.6s;
      "></div>
    </div>
    
    <style>
      @keyframes particle1 {
        0%, 100% { 
          transform: translate(-15px, -10px) scale(0.5); 
          opacity: 0; 
        }
        50% { 
          transform: translate(15px, 5px) scale(1); 
          opacity: 1; 
        }
      }
      @keyframes particle2 {
        0%, 100% { 
          transform: translate(-10px, 8px) scale(0.3); 
          opacity: 0; 
        }
        50% { 
          transform: translate(20px, -8px) scale(0.8); 
          opacity: 1; 
        }
      }
      @keyframes particle3 {
        0%, 100% { 
          transform: translate(-20px, 2px) scale(0.2); 
          opacity: 0; 
        }
        50% { 
          transform: translate(10px, -15px) scale(0.6); 
          opacity: 1; 
        }
      }
    </style>
  `;
  
  return L.divIcon({
    html: arrowHtml,
    className: 'white-dashed-arrow',
    iconSize: [80, 80],
    iconAnchor: [40, 40]
  });
};

// ‚ùå MARCADOR DE IMPACTO (X BRANCO)
const createImpactMarker = () => {
  const impactHtml = `
    <div style="
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: impactAnimation 1.5s ease-out;
    ">
      <svg width="40" height="40" viewBox="0 0 40 40">
        <defs>
          <filter id="glow">
            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
            <feMerge> 
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
        <!-- X de impacto -->
        <path d="M10 10 L30 30 M30 10 L10 30" 
              stroke="white" 
              stroke-width="4" 
              stroke-linecap="round"
              filter="url(#glow)"
              opacity="0.9">
        </path>
      </svg>
      <!-- Ondas de impacto -->
      <div style="
        position: absolute;
        width: 20px;
        height: 20px;
        border: 2px solid white;
        border-radius: 50%;
        animation: shockwave1 1s ease-out;
      "></div>
      <div style="
        position: absolute;
        width: 20px;
        height: 20px;
        border: 1px solid white;
        border-radius: 50%;
        animation: shockwave2 1s ease-out 0.2s;
      "></div>
    </div>
    
    <style>
      @keyframes impactAnimation {
        0% { 
          transform: scale(0) rotate(0deg); 
          opacity: 0; 
        }
        30% { 
          transform: scale(1.3) rotate(90deg); 
          opacity: 1; 
        }
        100% { 
          transform: scale(1) rotate(180deg); 
          opacity: 0.9; 
        }
      }
      @keyframes shockwave1 {
        0% { 
          transform: scale(1); 
          opacity: 0.8; 
        }
        100% { 
          transform: scale(3); 
          opacity: 0; 
        }
      }
      @keyframes shockwave2 {
        0% { 
          transform: scale(1); 
          opacity: 0.6; 
        }
        100% { 
          transform: scale(4); 
          opacity: 0; 
        }
      }
    </style>
  `;
  
  return L.divIcon({
    html: impactHtml,
    className: 'impact-marker',
    iconSize: [60, 60],
    iconAnchor: [30, 30]
  });
};

// üåç FUN√á√ÉO DE TRAJET√ìRIA CURVA SUAVE COM EASING
const calculateSmoothTrajectory = (start, end, numPoints = 15) => {
  const points = [];
  const [startLat, startLng] = start;
  const [endLat, endLng] = end;
  
  // Calcular dist√¢ncia para determinar intensidade da curva
  const distance = Math.sqrt(
    Math.pow(endLat - startLat, 2) + Math.pow(endLng - startLng, 2)
  );
  
  for (let i = 0; i <= numPoints; i++) {
    const rawT = i / numPoints;
    
    // üéØ EASING SUAVE (easeInOutCubic)
    const t = rawT < 0.5 
      ? 4 * rawT * rawT * rawT 
      : 1 - Math.pow(-2 * rawT + 2, 3) / 2;
    
    // Interpola√ß√£o base
    const lat = startLat + (endLat - startLat) * t;
    const lng = startLng + (endLng - startLng) * t;
    
    // ‚ú® CURVA NATURAL (par√°bola com varia√ß√µes)
    const curveFactor = Math.sin(t * Math.PI) * (distance * 0.3);
    const microVariation = Math.sin(t * Math.PI * 3) * (distance * 0.05);
    
    // üå™Ô∏è ROTA√á√ÉO DIN√ÇMICA DA SETA
    const baseRotation = Math.atan2(endLat - startLat, endLng - startLng) * (180/Math.PI);
    const dynamicRotation = baseRotation + Math.sin(t * Math.PI * 2) * 15;
    
    points.push({
      coordinates: [lat + curveFactor + microVariation, lng],
      progress: t * 100,
      rotation: dynamicRotation,
      timing: i * 200, // 200ms entre pontos para fluidez
      easing: t // Valor do easing para debug
    });
  }
  
  return points;
};

// Criar √≠cone da seta animada - VERS√ÉO ULTRA SIMPLES
const createArrowIcon = (isSpinning = false, phase = 'normal') => {
  const arrowHtml = `
    <div style="
      width: 50px; 
      height: 50px; 
      background: red;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 30px;
      color: white;
      border: 3px solid white;
      box-shadow: 0 4px 12px rgba(255, 0, 0, 0.5);
      ${phase === 'landing' ? 'animation: landBounce 1s ease-out;' : ''}
    ">
      üéØ
    </div>
    ${phase === 'landing' ? `
      <style>
        @keyframes landBounce {
          0% { transform: scale(0) rotate(0deg); }
          50% { transform: scale(1.3) rotate(180deg); }
          100% { transform: scale(1) rotate(360deg); }
        }
      </style>
    ` : ''}
  `;
  
  return new L.DivIcon({
    html: arrowHtml,
    className: `gm-map-arrow-marker`,
    iconSize: [50, 50],
    iconAnchor: [25, 25],
    popupAnchor: [0, -25],
  });
};

// √çcones modernos para diferentes tipos de viagem
const visitedIcon = createCustomIcon('#22c55e', 'visited'); // Verde
const futureIcon = createCustomIcon('#f97316', 'future'); // Laranja
const followingIcon = createCustomIcon('#3b82f6', 'following'); // Azul
const publicIcon = createCustomIcon('#eab308', 'public'); // Amarelo
const searchIcon = createCustomIcon('#8b5cf6', 'search'); // Roxo

// Componente para centralizar o mapa no local selecionado
const MapController = ({ selectedLocation }) => {
  const map = useMap();

  useEffect(() => {
    if (selectedLocation) {
      map.flyTo(selectedLocation.coordinates, selectedLocation.zoom, {
        duration: 1, // Anima√ß√£o de 1 segundo
      });
    }
  }, [selectedLocation, map]);

  return null;
};

const InteractiveMap = () => {
  const { user } = useAuth();
  const [locations, setLocations] = useState([]);
  const [futureTrips, setFutureTrips] = useState([]);
  const [followingTrips, setFollowingTrips] = useState([]); // azul
  const [publicTrips, setPublicTrips] = useState([]); // amarelo
  const [showWelcomePopup, setShowWelcomePopup] = useState(true);
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [selectedLocation, setSelectedLocation] = useState(null);
  const [randomPopup, setRandomPopup] = useState(null);
  const [searchMarker, setSearchMarker] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [mode, setMode] = useState("mine"); // 'mine' | 'all'
  const [showStatistics, setShowStatistics] = useState(false);
  const [showFilters, setShowFilters] = useState(false);
  const [showStreetView, setShowStreetView] = useState(false);
  const [streetViewPerson, setStreetViewPerson] = useState(null);
  // Toast state
  const [toast, setToast] = useState({ show: false, message: '', type: '' });
  
  // Estados para o "Spin the Globe" / "Atirar a Seta"
  const [isSpinning, setIsSpinning] = useState(false);
  const [arrowMarker, setArrowMarker] = useState(null);
  const [showDestinationPopup, setShowDestinationPopup] = useState(false);
  const [randomDestination, setRandomDestination] = useState(null);
  const [arrowAnimation, setArrowAnimation] = useState(null); // Para anima√ß√£o da seta
  const [trajectoryMarkers, setTrajectoryMarkers] = useState([]); // Para trajet√≥ria da seta
  const [launcherMarker, setLauncherMarker] = useState(null); // Para o boneco lan√ßador
  const [impactMarker, setImpactMarker] = useState(null); // Para marcador de impacto X
  const [showDestinationModal, setShowDestinationModal] = useState(false); // Modal do destino
  const [discoveredDestination, setDiscoveredDestination] = useState(null); // Pa√≠s descoberto
  
  // üé¨ ESTADOS DA SEQU√äNCIA CINEMATOGR√ÅFICA
  const [currentScene, setCurrentScene] = useState('idle'); // 'idle', 'balloon', 'arrow', 'plane', 'arrival', 'modal'
  const [showBalloon, setShowBalloon] = useState(false);
  const [showArrow, setShowArrow] = useState(false);
  const [showPlane, setShowPlane] = useState(false);
  const [arrowPosition, setArrowPosition] = useState({ x: 0, y: 0 });
  const [planePosition, setPlanePosition] = useState({ x: 0, y: 0 });
  const [targetDestination, setTargetDestination] = useState(null);
  const [cinematicInProgress, setCinematicInProgress] = useState(false);

  // Refer√™ncia para o componente cinematogr√°fico
  const cinematicRef = useRef(null);

  // Debug - log dos estados
  console.log('üîç Estados atuais:', { 
    isSpinning, 
    arrowMarker: !!arrowMarker, 
    arrowAnimation: !!arrowAnimation,
    launcherMarker: !!launcherMarker,
    randomDestination: !!randomDestination 
  });
  
  const [filters, setFilters] = useState({
    visited: true,
    future: true,
    following: true,
    public: true,
    dateRange: 'all',
    priceRange: 'all'
  });
  const mapRef = useRef(null);
  const navigate = useNavigate();

  // Toast functions
  const showToast = (message, type) => {
    setToast({ show: true, message, type });
    setTimeout(() => {
      setToast({ show: false, message: '', type: '' });
    }, 2600);
  };

  const closeToast = () => {
    setToast({ show: false, message: '', type: '' });
  };

  // üöÄ FUN√á√ïES DO MODAL DE DESTINO
  const handleExploreDestination = () => {
    if (discoveredDestination) {
      // Navegar para a p√°gina travels com filtro do pa√≠s
      navigate(`/travels?country=${encodeURIComponent(discoveredDestination.name)}`);
    }
  };

  const handleCloseDestinationModal = () => {
    setShowDestinationModal(false);
    setDiscoveredDestination(null);
    setImpactMarker(null);
  };

  // ÔøΩ SEQU√äNCIA CINEMATOGR√ÅFICA √âPICA
  const startCinematicSequence = () => {
    console.log('üé¨ TESTE: Fun√ß√£o chamada');
    
    if (cinematicInProgress) {
      console.log('‚ùå J√° em progresso');
      return;
    }
    
    // Reset total
    setShowBalloon(false);
    setShowArrow(false);
    setShowPlane(false);
    
    // Escolher destino
    const destination = worldCountries[Math.floor(Math.random() * worldCountries.length)];
    setTargetDestination(destination);
    
    console.log('‚úÖ Destino escolhido:', destination.name);
    
    // Activar sequ√™ncia
    setCinematicInProgress(true);
    setCurrentScene('balloon');
    
    // Mostrar bal√£o com delay
    setTimeout(() => {
      console.log('üéà A mostrar bal√£o');
      setShowBalloon(true);
    }, 200);
    
    // Auto-lan√ßa seta
    setTimeout(() => {
      console.log('ÔøΩ A lan√ßar seta');
      launchArrowSequence();
    }, 3000);
  };

  // üèπ CENA 2: LAN√áAMENTO DA SETA
  const launchArrowSequence = () => {
    console.log('üèπ Cena 2: Lan√ßamento da seta');
    setCurrentScene('arrow');
    showToast('üéØ Seta m√°gica lan√ßada!', 'info');
    
    // Posi√ß√µes fixas para garantir funcionamento
    const startX = window.innerWidth / 2;
    const startY = window.innerHeight * 0.3;
    const targetX = window.innerWidth * 0.7;
    const targetY = window.innerHeight * 0.6;
    
    setArrowPosition({ 
      startX, 
      startY, 
      targetX, 
      targetY
    });
    setShowArrow(true);
    setShowBalloon(false);
  };

  // ‚úàÔ∏è CENA 3: AVI√ÉO VIAJA
  const startPlaneSequence = () => {
    console.log('‚úàÔ∏è Cena 3: Avi√£o parte em viagem');
    setCurrentScene('plane');
    showToast('‚úàÔ∏è Avi√£o a caminho do destino!', 'info');
    
    if (!targetDestination || !arrowPosition) return;
    
    // Trajet√≥ria simples e fixa
    const planePath = [
      { x: 0, y: window.innerHeight / 2, rotation: 0 },
      { x: window.innerWidth * 0.25, y: window.innerHeight * 0.4, rotation: -10 },
      { x: window.innerWidth * 0.5, y: window.innerHeight * 0.35, rotation: 0 },
      { x: window.innerWidth * 0.75, y: window.innerHeight * 0.45, rotation: 10 },
      { x: arrowPosition.targetX, y: arrowPosition.targetY, rotation: 0 }
    ];
    
    setPlanePosition({ path: planePath });
    setShowPlane(true);
    setShowArrow(false);
    
    // Zoom para o destino
    if (targetDestination) {
      setTimeout(() => {
        setSelectedLocation({
          coordinates: targetDestination.coordinates,
          zoom: targetDestination.zoom || 7,
          name: targetDestination.name
        });
      }, 1000);
    }
  };

  // üìç CENA 4: CHEGADA E MODAL
  const finalizeCinematicSequence = () => {
    console.log('üìç Cena 4: Chegada ao destino');
    setCurrentScene('arrival');
    setShowPlane(false);
    
    const userName = user?.username || user?.name || 'Aventureiro';
    
    // Mostrar marcador de impacto
    setImpactMarker({
      coordinates: targetDestination.coordinates,
      country: targetDestination.name,
      icon: createImpactMarker(),
      timestamp: Date.now()
    });
    
    // Aguardar 3 segundos para o modal
    setTimeout(() => {
      setCurrentScene('modal');
      setDiscoveredDestination({
        ...targetDestination,
        discoveredBy: userName,
        discoveredAt: new Date().toISOString()
      });
      setShowDestinationModal(true);
      setCinematicInProgress(false);
      setIsSpinning(false);
      
      showToast(`üé¨ Sequ√™ncia completa! Chegaste a ${targetDestination.name}!`, 'success');
    }, 3000);
  };

  // ÔøΩüéØ NOVA ANIMA√á√ÉO DA SETA TRACEJADA BRANCA
  const animateWhiteDashedArrow = (startCoords, endCoords, destination, userName) => {
    const trajectoryPoints = calculateSmoothTrajectory(startCoords, endCoords, 18);
    
    console.log('‚ú® Iniciando seta tracejada branca:', trajectoryPoints.length, 'pontos');
    showToast('üéØ Acompanha a seta m√°gica!', 'info');
    
    // Limpar estados anteriores
    setArrowAnimation(null);
    setImpactMarker(null);
    setArrowMarker(null);
    
    trajectoryPoints.forEach((point, index) => {
      setTimeout(() => {
        console.log(`‚ú® Ponto ${index + 1}/${trajectoryPoints.length}:`, point.coordinates);
        
        // Mostrar seta tracejada branca com rota√ß√£o din√¢mica
        setArrowAnimation({
          coordinates: point.coordinates,
          progress: point.progress,
          rotation: point.rotation,
          icon: createWhiteDashedArrow(point.progress, point.rotation),
          phase: 'flying',
          destination: destination.name,
          pointIndex: index + 1,
          totalPoints: trajectoryPoints.length,
          easing: point.easing
        });

        // üéØ CHEGADA AO DESTINO FINAL
        if (index === trajectoryPoints.length - 1) {
          setTimeout(() => {
            console.log('üí• IMPACTO! Seta chegou ao destino!');
            
            // Remover seta voadora
            setArrowAnimation(null);
            
            // Mostrar marcador de impacto (X branco)
            setImpactMarker({
              coordinates: endCoords,
              country: destination.name,
              icon: createImpactMarker(),
              timestamp: Date.now()
            });
            
            // Zoom suave para o destino
            setTimeout(() => {
              setSelectedLocation({
                coordinates: endCoords,
                zoom: destination.zoom || 7,
                name: destination.name
              });
            }, 300);
            
            // üïê AGUARDAR 3 SEGUNDOS PARA O MODAL
            setTimeout(() => {
              setDiscoveredDestination({
                ...destination,
                discoveredBy: userName,
                discoveredAt: new Date().toISOString()
              });
              setShowDestinationModal(true);
              setIsSpinning(false);
              
              showToast(`ÔøΩ Destino descoberto: ${destination.name}!`, 'success');
            }, 3000);
            
          }, 400);
        }
      }, point.timing);
    });
  };

  // Lista de pa√≠ses populares para o "Spin the Globe"
  const worldCountries = [
    { name: 'Fran√ßa', coordinates: [46.2276, 2.2137], zoom: 6 },
    { name: 'Espanha', coordinates: [40.4637, -3.7492], zoom: 6 },
    { name: 'It√°lia', coordinates: [41.8719, 12.5674], zoom: 6 },
    { name: 'Portugal', coordinates: [39.3999, -8.2245], zoom: 7 },
    { name: 'Alemanha', coordinates: [51.1657, 10.4515], zoom: 6 },
    { name: 'Reino Unido', coordinates: [55.3781, -3.4360], zoom: 6 },
    { name: 'Jap√£o', coordinates: [36.2048, 138.2529], zoom: 6 },
    { name: 'Tail√¢ndia', coordinates: [15.8700, 100.9925], zoom: 6 },
    { name: 'Brasil', coordinates: [-14.2350, -51.9253], zoom: 5 },
    { name: 'Estados Unidos', coordinates: [37.0902, -95.7129], zoom: 4 },
    { name: 'Austr√°lia', coordinates: [-25.2744, 133.7751], zoom: 5 },
    { name: '√çndia', coordinates: [20.5937, 78.9629], zoom: 5 },
    { name: 'China', coordinates: [35.8617, 104.1954], zoom: 4 },
    { name: 'Canad√°', coordinates: [56.1304, -106.3468], zoom: 4 },
    { name: 'M√©xico', coordinates: [23.6345, -102.5528], zoom: 5 },
    { name: 'Argentina', coordinates: [-38.4161, -63.6167], zoom: 5 },
    { name: 'Chile', coordinates: [-35.6751, -71.5430], zoom: 5 },
    { name: 'Peru', coordinates: [-9.1900, -75.0152], zoom: 6 },
    { name: 'Egito', coordinates: [26.0975, 31.2357], zoom: 6 },
    { name: '√Åfrica do Sul', coordinates: [-30.5595, 22.9375], zoom: 6 },
    { name: 'Marrocos', coordinates: [31.7917, -7.0926], zoom: 6 },
    { name: 'Turquia', coordinates: [38.9637, 35.2433], zoom: 6 },
    { name: 'Gr√©cia', coordinates: [39.0742, 21.8243], zoom: 7 },
    { name: 'Cro√°cia', coordinates: [45.1, 15.2], zoom: 7 },
    { name: 'Noruega', coordinates: [60.4720, 8.4689], zoom: 6 },
    { name: 'Su√©cia', coordinates: [60.1282, 18.6435], zoom: 6 },
    { name: 'Finl√¢ndia', coordinates: [61.9241, 25.7482], zoom: 6 },
    { name: 'Isl√¢ndia', coordinates: [64.9631, -19.0208], zoom: 7 },
    { name: 'R√∫ssia', coordinates: [61.5240, 105.3188], zoom: 3 },
    { name: 'Coreia do Sul', coordinates: [35.9078, 127.7669], zoom: 7 },
    { name: 'Singapura', coordinates: [1.3521, 103.8198], zoom: 11 },
    { name: 'Mal√°sia', coordinates: [4.2105, 101.9758], zoom: 6 },
    { name: 'Indon√©sia', coordinates: [-0.7893, 113.9213], zoom: 5 },
    { name: 'Filipinas', coordinates: [12.8797, 121.7740], zoom: 6 },
    { name: 'Vietn√£', coordinates: [14.0583, 108.2772], zoom: 6 },
    { name: 'Camboja', coordinates: [12.5657, 104.9910], zoom: 7 },
    { name: 'Nepal', coordinates: [28.3949, 84.1240], zoom: 7 },
    { name: 'Sri Lanka', coordinates: [7.8731, 80.7718], zoom: 8 },
    { name: 'Maldivas', coordinates: [3.2028, 73.2207], zoom: 8 },
    { name: 'Emirados √Årabes Unidos', coordinates: [23.4241, 53.8478], zoom: 7 },
    { name: 'Israel', coordinates: [31.0461, 34.8516], zoom: 8 },
    { name: 'Jord√¢nia', coordinates: [30.5852, 36.2384], zoom: 7 },
    { name: 'Qu√©nia', coordinates: [-0.0236, 37.9062], zoom: 6 },
    { name: 'Tanz√¢nia', coordinates: [-6.3690, 34.8888], zoom: 6 },
    { name: 'Madag√°scar', coordinates: [-18.7669, 46.8691], zoom: 6 },
    { name: 'Nova Zel√¢ndia', coordinates: [-40.9006, 174.8860], zoom: 6 },
    { name: 'Fiji', coordinates: [-16.5789, 179.4144], zoom: 8 },
    { name: 'Costa Rica', coordinates: [9.7489, -83.7534], zoom: 8 },
    { name: 'Col√¥mbia', coordinates: [4.5709, -74.2973], zoom: 6 },
    { name: 'Equador', coordinates: [-1.8312, -78.1834], zoom: 7 },
    { name: 'Bol√≠via', coordinates: [-16.2902, -63.5887], zoom: 6 }
  ];

  // Fun√ß√£o principal do "Spin the Globe" - VERS√ÉO ULTRA SIMPLES QUE FUNCIONA!
  // üé¨ FUN√á√ÉO PRINCIPAL CINEMATOGR√ÅFICA
  const spinTheGlobe = () => {
    console.log('üé¨ Globe Memories: Iniciando sequ√™ncia cinematogr√°fica!');
    
    // Usar o novo componente cinematogr√°fico
    if (cinematicRef.current) {
      cinematicRef.current.start();
    } else {
      console.error('‚ùå Componente cinematogr√°fico n√£o dispon√≠vel');
    }
  };
  
  // Handler para quando um destino √© selecionado na sequ√™ncia
  const handleDestinationSelected = (destination) => {
    console.log('üéØ Destino selecionado:', destination);
    
    if (destination.coordinates) {
      // Zoom para o destino
      setSelectedLocation({
        coordinates: destination.coordinates,
        zoom: 8,
        name: `${destination.name}, ${destination.country}`
      });
      
      // Mostrar toast de sucesso
      showToast(`üéâ Chegaste a ${destination.name}! Explora as viagens dispon√≠veis.`, 'success');
    }
  };
    
    // üéà CENA 1: MOSTRAR BAL√ÉO (imediatamente)
    console.log('üéà Cena 1: Bal√£o aparece');
    setCurrentScene('balloon');
    setShowBalloon(true);
  };

  // Fun√ß√£o para aterrar a seta no destino final - VERS√ÉO SIMPLIFICADA
  const landArrowAtDestination = (destination) => {
    console.log('üéØ Aterrando no destino:', destination.name);
    
    showToast('üéØ Alvo atingido!', 'success');
    
    const landedArrow = createArrowIcon(false, 'landing');
    
    // Colocar seta no destino final
    setArrowMarker({
      coordinates: destination.coordinates,
      country: destination.name,
      icon: landedArrow
    });
    
    // Limpar anima√ß√£o
    setArrowAnimation(null);

    // Fazer zoom para o pa√≠s
    setSelectedLocation({
      coordinates: destination.coordinates,
      zoom: destination.zoom,
      name: destination.name
    });

    // Definir o destino descoberto
    setRandomDestination(destination);
    
    setIsSpinning(false);
    
    // Mostrar popup ap√≥s 1 segundo
    setTimeout(() => {
      console.log('üéä Mostrando popup de destino...');
      setShowDestinationPopup(true);
      showToast(`üåç Destino descoberto: ${destination.name}!`, 'success');
    }, 1000);
  };

  // Fun√ß√£o para ir para a p√°gina de viagens filtrada pelo pa√≠s
  const goToCountryTravels = () => {
    if (randomDestination) {
      // Limpar estados
      setShowDestinationPopup(false);
      setArrowMarker(null);
      setRandomDestination(null);
      
      // Navegar para a p√°gina de viagens com filtro
      navigate('/travels', { 
        state: { 
          filterByCountry: randomDestination.name,
          message: `Descobrindo viagens em ${randomDestination.name}! üåç`
        } 
      });
    }
  };

  // Fun√ß√£o para fechar o popup de destino
  const closeDestinationPopup = () => {
    setShowDestinationPopup(false);
    setArrowMarker(null);
    setRandomDestination(null);
    setArrowAnimation(null);
    setLauncherMarker(null);
  };

  const MAPTILER_API_KEY = "G59o5q9sfWGLLQJsw3v7";

  // M√∫ltiplas op√ß√µes de mapas para melhor qualidade
  const mapLayers = {
    streets: {
      url: `https://api.maptiler.com/maps/streets-v2/{z}/{x}/{y}.png?key=${MAPTILER_API_KEY}`,
      attribution: '&copy; <a href="https://www.maptiler.com/">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors'
    },
    satellite: {
      url: `https://api.maptiler.com/maps/satellite/{z}/{x}/{y}.jpg?key=${MAPTILER_API_KEY}`,
      attribution: '&copy; <a href="https://www.maptiler.com/">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors'
    },
    terrain: {
      url: `https://api.maptiler.com/maps/outdoor-v2/{z}/{x}/{y}.png?key=${MAPTILER_API_KEY}`,
      attribution: '&copy; <a href="https://www.maptiler.com/">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors'
    },
    basic: {
      url: `https://api.maptiler.com/maps/basic-v2/{z}/{x}/{y}.png?key=${MAPTILER_API_KEY}`,
      attribution: '&copy; <a href="https://www.maptiler.com/">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors'
    }
  };

  // Fun√ß√£o para obter coordenadas e nome em pt-PT usando Nominatim
  const getCoordinates = async (country, city) => {
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(city)},${encodeURIComponent(country)}&format=json&limit=1&accept-language=pt-PT`
      );
      const data = await response.json();
      if (data.length > 0) {
        return {
          coordinates: [parseFloat(data[0].lat), parseFloat(data[0].lon)],
          name: data[0].display_name.split(",")[0],
        };
      }
    } catch (error) {
      console.error(`Erro ao obter coordenadas para ${city}, ${country}:`, error);
      showToast(`Erro ao obter coordenadas para ${city}. Tente novamente.`, 'error');
    }
    return null;
  };

  // Fun√ß√£o para formatar o tipo de local
  const formatLocationType = (type, address) => {
    if (type === 'country') return 'Pa√≠s';
    if (type === 'city' || type === 'town' || type === 'village') return 'Cidade';
    if (type === 'state' || type === 'administrative') return 'Local';
    if (type === 'suburb' || type === 'neighbourhood') return 'Bairro';
    if (type === 'attraction' || type === 'landmark') return 'Ponto Tur√≠stico';
    if (address?.tourism) return 'Ponto Tur√≠stico';
    if (address?.historic) return 'Local Hist√≥rico';
    return 'Local';
  };

  // Fun√ß√£o para formatar o nome do local
  const formatLocationName = (result) => {
    const parts = result.display_name.split(',');
    if (result.type === 'country') return `${parts[0]} - Pa√≠s`;
    if (result.type === 'city' || result.type === 'town') {
      const city = parts[0];
      const region = parts[parts.length - 3]?.trim();
      const country = parts[parts.length - 1]?.trim();
      return `${city}${region ? `, ${region}` : ''}${country ? ` - ${country}` : ''}`;
    }
    return result.display_name.replace(/, Portugal$/, '').replace(/,.*$/, '');
  };

  // Fun√ß√£o para buscar locais com busca mais ampla e precisa
  const searchLocations = async (query) => {
    if (query.length < 1) {
      setSearchResults([]);
      setIsLoading(false);
      return;
    }
    setIsLoading(true);
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=8&accept-language=pt-PT&addressdetails=1`
      );
      const data = await response.json();
      
      // Processar e formatar os resultados
      const processedResults = data.map((result) => {
        const locationType = formatLocationType(result.type, result.address);
        const displayName = formatLocationName(result);
        
        return {
          ...result,
          display_name: displayName,
          type: locationType,
          zoom: result.type === "country" ? 5 : 
               result.type === "city" || result.type === "town" ? 10 : 
               result.type === "village" ? 12 : 14,
          address_details: result.address
        };
      });

      // Ordenar por relev√¢ncia (importance) e tipo
      const sortedResults = processedResults.sort((a, b) => {
        if (a.type === 'Pa√≠s' && b.type !== 'Pa√≠s') return -1;
        if (b.type === 'Pa√≠s' && a.type !== 'Pa√≠s') return 1;
        if (a.type === 'Cidade' && b.type !== 'Cidade') return -1;
        if (b.type === 'Cidade' && a.type !== 'Cidade') return 1;
        return (b.importance || 0) - (a.importance || 0);
      });

      setSearchResults(sortedResults);
    } catch (error) {
      console.error("Erro ao buscar locais:", error);
      showToast('Erro ao buscar locais. Tente novamente.', 'error');
      setSearchResults([]);
    } finally {
      setIsLoading(false);
    }
  };

  // Debounce para otimizar a busca
  const debouncedSearch = useCallback(debounce((query) => searchLocations(query), 300), []);

  // Util: valida se a viagem tem coordenadas v√°lidas
  const hasValidCoords = (t) => {
    if (!t || !Array.isArray(t.coordinates) || t.coordinates.length !== 2) return false;
    const lat = Number(t.coordinates[0]);
    const lng = Number(t.coordinates[1]);
    return Number.isFinite(lat) && Number.isFinite(lng);
  };

  // Fun√ß√£o para obter pa√≠s e cidade a partir de coordenadas
  const getLocationFromCoordinates = async (lat, lng) => {
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&accept-language=pt-PT`
      );
      const data = await response.json();
      console.log("Dados de localiza√ß√£o recebidos:", data); // Debug
      if (data && data.address) {
        const country = data.address.country || 
                       data.address.country_code?.toUpperCase() || 
                       "Desconhecido";
        const city = data.address.city || 
                    data.address.town || 
                    data.address.village || 
                    data.address.municipality || 
                    data.address.hamlet || 
                    data.address.suburb ||
                    "Desconhecido";
        
        console.log(`Localiza√ß√£o processada: ${city}, ${country}`); // Debug
        return { country, city };
      }
    } catch (error) {
      console.error(`Erro ao obter localiza√ß√£o para ${lat}, ${lng}:`, error);
    }
    return { country: "Desconhecido", city: "Desconhecido" };
  };

  // Carrega as viagens futuras e visitadas do localStorage
  useEffect(() => {
    const savedFutureTrips = JSON.parse(localStorage.getItem("futureTrips")) || [];
    setFutureTrips(savedFutureTrips);

    const savedVisitedTrips = JSON.parse(localStorage.getItem("visitedTrips")) || [];
    setLocations(savedVisitedTrips);

    // Dados mock/armazenados: viagens de seguidos e p√∫blicas
    const savedFollowingTrips = JSON.parse(localStorage.getItem("followingTrips")) || [];
    setFollowingTrips(savedFollowingTrips);
    const savedPublicTrips = JSON.parse(localStorage.getItem("publicTrips")) || [];
    setPublicTrips(savedPublicTrips);

    const fetchCoordinates = async () => {
      // Mostrar TODAS as viagens (mesmo que na mesma cidade), evitando s√≥ geocoding duplicado
      const geoCache = new Map(); // key: "City, Country" -> { coordinates, name }
      const locationsWithCoords = [];

      for (const travel of travels) {
        const key = `${travel.city}, ${travel.country}`;
        let geo = geoCache.get(key);
        if (!geo) {
          geo = await getCoordinates(travel.country, travel.city);
          if (geo) geoCache.set(key, geo);
        }
        if (geo) {
          locationsWithCoords.push({
            city: travel.city,
            country: travel.country,
            startDate: travel.startDate,
            price: travel.price,
            tripLink: `/travel/${travel.id}`,
            user: travel.user,
            coordinates: geo.coordinates,
            displayName: geo.name,
          });
        }
      }

      setLocations(locationsWithCoords);
      localStorage.setItem("visitedTrips", JSON.stringify(locationsWithCoords));
    };

    fetchCoordinates();
  }, []);

  // Enriquecer viagens p√∫blicas e de quem sigo com coordenadas caso faltem
  useEffect(() => {
    const enrich = async () => {
      let changedPublic = false;
      let changedFollowing = false;

      const enrichList = async (list) => {
        const result = [];
        for (const t of list || []) {
          if (!t) { result.push(t); continue; }
          // 1) Se j√° existem coordenadas, tentar normalizar para n√∫meros
          if (Array.isArray(t.coordinates) && t.coordinates.length === 2) {
            const lat = Number(t.coordinates[0]);
            const lng = Number(t.coordinates[1]);
            if (Number.isFinite(lat) && Number.isFinite(lng)) {
              result.push({ ...t, coordinates: [lat, lng] });
              continue;
            }
          }

          // 2) Tentar geocodificar usando country/city
          let city = t.city;
          let country = t.country;

          // 2a) Se n√£o houver city/country, tentar inferir do label "City, Country"
          if ((!city || !country) && t.label && typeof t.label === 'string') {
            const parts = t.label.split(',').map(s => s.trim());
            if (parts.length >= 2) {
              city = city || parts[0];
              country = country || parts[parts.length - 1];
            }
          }

          // 2b) Se ainda faltar, n√£o conseguimos enriquecer
          if (!city || !country) {
            result.push(t);
            continue;
          }

          try {
            const geo = await getCoordinates(country, city);
            if (geo && Array.isArray(geo.coordinates)) {
              result.push({ ...t, city, country, coordinates: geo.coordinates });
            } else {
              result.push(t);
            }
          } catch (e) {
            console.warn('Falha ao geocodificar viagem', t);
            result.push(t);
          }
        }
        return result;
      };

      // PublicTrips
      const needsPublic = (publicTrips || []).some(t => !Array.isArray(t?.coordinates) ||
        (Array.isArray(t?.coordinates) && (!Number.isFinite(Number(t.coordinates[0])) || !Number.isFinite(Number(t.coordinates[1]))))
      );
      let newPublic = publicTrips;
      if (needsPublic) {
        newPublic = await enrichList(publicTrips);
        if (JSON.stringify(newPublic) !== JSON.stringify(publicTrips)) {
          changedPublic = true;
        }
      }

      // FollowingTrips
      const needsFollowing = (followingTrips || []).some(t => !Array.isArray(t?.coordinates) ||
        (Array.isArray(t?.coordinates) && (!Number.isFinite(Number(t.coordinates[0])) || !Number.isFinite(Number(t.coordinates[1]))))
      );
      let newFollowing = followingTrips;
      if (needsFollowing) {
        newFollowing = await enrichList(followingTrips);
        if (JSON.stringify(newFollowing) !== JSON.stringify(followingTrips)) {
          changedFollowing = true;
        }
      }

      if (changedPublic) {
        setPublicTrips(newPublic);
        localStorage.setItem('publicTrips', JSON.stringify(newPublic));
      }
      if (changedFollowing) {
        setFollowingTrips(newFollowing);
        localStorage.setItem('followingTrips', JSON.stringify(newFollowing));
      }
    };

    // Apenas corre se houver algo a enriquecer
    if (
      (publicTrips || []).some(t => !Array.isArray(t?.coordinates) || (Array.isArray(t?.coordinates) && (!Number.isFinite(Number(t.coordinates[0])) || !Number.isFinite(Number(t.coordinates[1]))))) ||
      (followingTrips || []).some(t => !Array.isArray(t?.coordinates) || (Array.isArray(t?.coordinates) && (!Number.isFinite(Number(t.coordinates[0])) || !Number.isFinite(Number(t.coordinates[1])))))
    ) {
      enrich();
    }
  }, [publicTrips, followingTrips]);

  const myVisited = useMemo(() => locations, [locations]);
  const myFuture = useMemo(() => futureTrips, [futureTrips]);

  const filteredSets = useMemo(() => {
    let visited = myVisited;
    let future = myFuture;
    let following = followingTrips || [];
    let publicTripsData = publicTrips || [];

    // Aplicar filtros
    if (!filters.visited) visited = [];
    if (!filters.future) future = [];
    if (!filters.following) following = [];
    if (!filters.public) publicTripsData = [];

    if (mode === 'mine') {
      // Apenas as minhas viagens (conclu√≠das e futuras)
      return { visited, future, following: [], public: [] };
    }
    // mode === 'all' -> Apenas viagens de outros (quem sigo e p√∫blicas)
    return {
      visited: [],
      future: [],
      following,
      public: publicTripsData,
    };
  }, [mode, myVisited, myFuture, followingTrips, publicTrips, filters]);

  // Componente para gerenciar eventos do mapa
const MapEvents = () => {
  const map = useMapEvents({
    click: async (e) => {
      // Verifica se o clique foi em um marcador ou popup
      const target = e.originalEvent.target;
      if (target.closest('.leaflet-popup') || target.closest('.leaflet-marker-icon')) {
        return;
      }

      // Verifica se o clique foi parte de um arrasto
      if (e.originalEvent.type === 'mousedown' || e.originalEvent.type === 'mouseup') {
        return;
      }

      // Verifica se o clique foi em um bot√£o ou elemento interativo
      if (target.closest('button') || target.closest('a')) {
        return;
      }

      // Verifica se o clique foi no mapa (n√£o em elementos sobrepostos)
      if (!target.closest('.leaflet-container')) {
        return;
      }
      
      // S√≥ permite adicionar viagens futuras no modo 'mine'
      if (mode !== 'mine') {
        return;
      }

      const { lat, lng } = e.latlng;
      console.log(`Clique no mapa em: ${lat}, ${lng}`); // Debug
      const location = await getLocationFromCoordinates(lat, lng);
      console.log("Localiza√ß√£o obtida:", location); // Debug
      const newFutureTrip = {
        coordinates: [lat, lng],
        label: `Viagem Futura a ${location.city}`,
        country: location.country,
        city: location.city,
      };
      console.log("newFutureTrip criada:", newFutureTrip); // Debug

      // Adicionar ao futureTrips
      setFutureTrips((prevTrips) => {
        const updatedTrips = [...prevTrips, newFutureTrip];
        localStorage.setItem("futureTrips", JSON.stringify(updatedTrips));
        return updatedTrips;
      });

      // Adicionar ao futureTravels com valores padr√£o
      const futureTravels = JSON.parse(localStorage.getItem("futureTravels")) || [];
      // Calcular a data de in√≠cio como o dia seguinte
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(today.getDate() + 1);
      
      // Define a data de fim como 6 dias ap√≥s a data de in√≠cio
      const nextWeek = new Date(tomorrow);
      nextWeek.setDate(tomorrow.getDate() + 6);

      // Formata as datas para o formato YYYY-MM-DD
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };

      const newTravel = {
        id: Date.now(), // Usar timestamp para IDs √∫nicos
        name: `Viagem Futura a ${location.city}`,
        user: "Tiago",
        category: [],
        country: location.country,
        city: location.city,
        price: "",
        startDate: formatDate(tomorrow),
        endDate: formatDate(nextWeek),
        BookingTripPaymentDate: "",
        priceDetails: { hotel: "", transport: "", food: "", extras: "" },
        description: "",
        accommodations: [{ name: "", type: "" }],
        pointsOfInterest: [],
        itinerary: [],
        localTransport: [],
        privacy: "public",
        checklist: [],
        coordinates: [lat, lng],
        travelType: { // Adicionar estrutura de tipo de viagem
          main: 'single', // Por padr√£o, viagens criadas no mapa s√£o de destino √∫nico
          isGroup: false
        }
      };
      console.log("newTravel criada:", newTravel); // Debug

      futureTravels.push(newTravel);
      localStorage.setItem("futureTravels", JSON.stringify(futureTravels));
    },
  });

  map.setMaxBounds([[-90, -180], [90, 180]]);
  map.setMinZoom(3);
  return null;
};

  // Fun√ß√£o para remover viagem futura
  const removeFutureTrip = (trip) => {
    // Remover do futureTrips
    setFutureTrips((prevTrips) => {
      const updatedTrips = prevTrips.filter(t => 
        !(t.coordinates[0] === trip.coordinates[0] && 
          t.coordinates[1] === trip.coordinates[1])
      );
      localStorage.setItem("futureTrips", JSON.stringify(updatedTrips));
      return updatedTrips;
    });

    // Remover do futureTravels no localStorage
    const futureTravels = JSON.parse(localStorage.getItem("futureTravels")) || [];
    const updatedFutureTravels = futureTravels.filter(t => 
      !(t.coordinates[0] === trip.coordinates[0] && 
        t.coordinates[1] === trip.coordinates[1])
    );
    localStorage.setItem("futureTravels", JSON.stringify(updatedFutureTravels));
  };

  // Fun√ß√£o para verificar se o local j√° existe como viagem futura
  const isLocationInFutureTrips = (coordinates) => {
    if (!coordinates || !Array.isArray(coordinates) || coordinates.length !== 2) {
      return false;
    }
    return futureTrips.some(trip => 
      trip.coordinates && 
      Array.isArray(trip.coordinates) && 
      trip.coordinates.length === 2 &&
      trip.coordinates[0] === coordinates[0] && 
      trip.coordinates[1] === coordinates[1]
    );
  };

  // Fun√ß√£o para fechar o popup de boas-vindas
  const closeWelcomePopup = () => setShowWelcomePopup(false);

  // Fun√ß√£o para gerar o link do Google Maps
  const getGoogleMapsLink = (lat, lng) => `https://www.google.com/maps?q=${lat},${lng}`;

  // Fun√ß√£o para extrair o pa√≠s e a cidade do resultado da pesquisa
  const extractLocationInfo = (result) => {
    const address = result.address || {};
    let country = '';
    let city = '';

    // Tenta obter o pa√≠s de diferentes campos poss√≠veis
    if (address.country) {
      country = address.country;
    } else if (address.country_code) {
      country = address.country_code.toUpperCase();
    } else if (result.display_name) {
      // Se n√£o encontrar nos campos espec√≠ficos, tenta extrair do display_name
      const parts = result.display_name.split(',');
      if (parts.length > 0) {
        country = parts[parts.length - 1].trim();
      }
    }

    // Tenta obter a cidade de diferentes campos poss√≠veis
    if (address.city) {
      city = address.city;
    } else if (address.town) {
      city = address.town;
    } else if (address.village) {
      city = address.village;
    } else if (address.municipality) {
      city = address.municipality;
    } else if (result.display_name) {
      // Se n√£o encontrar nos campos espec√≠ficos, usa a primeira parte do display_name
      const parts = result.display_name.split(',');
      if (parts.length > 1) {
        city = parts[0].trim();
      }
    }

    return { country, city };
  };

  // Fun√ß√£o para abrir o Street View do Google Maps
  const openStreetView = (lat, lng) => {
    const streetViewUrl = `https://www.google.com/maps/@${lat},${lng},3a,75y,0h,90t/data=!3m7!1e1!3m5!1s0x0:0x0!2e0!6shttps:%2F%2Fstreetviewpixels-pa.googleapis.com%2Fv1%2Fthumbnail%3Fpanoid%3D${lat}_${lng}%26cb_client%3Dsearch.gws-prod.gps%26w%3D86%26h%3D86%26yaw%3D0%26pitch%3D0%26thumbfov%3D100!7i16384!8i8192`;
    window.open(streetViewUrl, '_blank');
  };

  // Fun√ß√£o para selecionar um local da pesquisa
  const handleSelectLocation = (result) => {
    const coordinates = [parseFloat(result.lat), parseFloat(result.lon)];
    const { country, city } = extractLocationInfo(result);
    
    setSelectedLocation({
      coordinates,
      name: result.display_name,
      zoom: result.zoom || (result.type === "Pa√≠s" ? 5 : result.type === "Cidade" ? 10 : 14),
      radius: result.type === "Pa√≠s" ? 50000 : 
             result.type === "Cidade" ? 10000 : 
             result.type === "Regi√£o" ? 20000 : 5000
    });
    
    // Adicionar marcador para o local pesquisado com informa√ß√µes detalhadas
    setSearchMarker({
      coordinates,
      name: result.display_name,
      country,
      city,
      address: result.address || {}
    });
    
    setSearchQuery("");
    setSearchResults([]);
  };

  // Fun√ß√£o para sanitizar input de pesquisa
  const sanitizeSearchInput = (input) => {
    if (!input) return '';
    
    // Remove caracteres perigosos e scripts
    return input
      .replace(/<script[^>]*>.*?<\/script>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '')
      .replace(/[<>]/g, '')
      .trim();
  };

  // Fun√ß√£o para validar input de localiza√ß√£o
  const validateLocationInput = (input) => {
    if (!input) return { isValid: true, sanitized: '' };
    
    if (input.length > 100) {
      showToast('Pesquisa n√£o pode exceder 100 caracteres!', 'error');
      return { isValid: false, sanitized: input };
    }

    const sanitized = sanitizeSearchInput(input);
    
    if (sanitized !== input.trim()) {
      showToast('Pesquisa cont√©m caracteres n√£o permitidos que foram removidos!', 'error');
    }

    // Validar se cont√©m apenas caracteres permitidos (letras, n√∫meros, espa√ßos, v√≠rgulas, h√≠fens)
    if (!/^[a-zA-Z√Ä-√ø0-9\s,.\-''`]+$/.test(sanitized)) {
      showToast('Pesquisa cont√©m caracteres n√£o permitidos!', 'error');
      return { isValid: false, sanitized: input };
    }

    return { isValid: true, sanitized };
  };

  // Handler para a mudan√ßa no campo de pesquisa
  const handleSearchChange = (e) => {
    const rawQuery = e.target.value;
    const validation = validateLocationInput(rawQuery);
    
    if (!validation.isValid) {
      return;
    }
    
    setSearchQuery(validation.sanitized);
    debouncedSearch(validation.sanitized);
  };

  // Fun√ß√£o para adicionar viagem futura a partir do marcador de pesquisa
  const addFutureTripFromSearch = (marker) => {
    const newFutureTrip = {
      coordinates: marker.coordinates,
      label: `Viagem Futura a ${marker.name}`,
      country: marker.name.split(',')[marker.name.split(',').length - 1]?.trim() || "Desconhecido",
      city: marker.name.split(',')[0]?.trim() || "Desconhecido",
    };

    // Adicionar ao futureTrips
    setFutureTrips((prevTrips) => {
      const updatedTrips = [...prevTrips, newFutureTrip];
      localStorage.setItem("futureTrips", JSON.stringify(updatedTrips));
      return updatedTrips;
    });

    // Adicionar ao futureTravels com valores padr√£o
    const futureTravels = JSON.parse(localStorage.getItem("futureTravels")) || [];
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(today.getDate() + 1);
    
    // Define a data de fim como 6 dias ap√≥s a data de in√≠cio
    const nextWeek = new Date(tomorrow);
    nextWeek.setDate(tomorrow.getDate() + 6);

    // Formata as datas para o formato YYYY-MM-DD
    const formatDate = (date) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };

    const newTravel = {
      id: Date.now(),
      name: `Viagem Futura a ${marker.name}`,
      user: "Tiago",
      category: [],
      country: newFutureTrip.country,
      city: newFutureTrip.city,
      price: "",
      startDate: formatDate(tomorrow),
      endDate: formatDate(nextWeek),
      BookingTripPaymentDate: "",
      priceDetails: { hotel: "", transport: "", food: "", extras: "" },
      description: "",
      accommodations: [{ name: "", type: "" }],
      pointsOfInterest: [],
      itinerary: [],
      localTransport: [],
      privacy: "public",
      checklist: [],
      coordinates: marker.coordinates,
      travelType: { // Adicionar estrutura de tipo de viagem
        main: 'single', // Por padr√£o, viagens criadas no mapa s√£o de destino √∫nico
        isGroup: false
      }
    };

    futureTravels.push(newTravel);
    localStorage.setItem("futureTravels", JSON.stringify(futureTravels));
  };

  return (
    <div className="gm-map-container">
      {/* Header transparente com controles e pesquisa */}
      <div className="gm-map-header">
        <div className="gm-map-controls">
          <button
            className={`gm-map-control-btn ${mode === 'mine' ? 'active' : ''}`}
            onClick={() => setMode('mine')}
          >
            <span className="gm-map-btn-icon">üè†</span>
            As Minhas Viagens
          </button>
          <button
            className={`gm-map-control-btn ${mode === 'all' ? 'active' : ''}`}
            onClick={() => setMode('all')}
          >
            <span className="gm-map-btn-icon">üåç</span>
            Todos os Viajantes
          </button>
          
          <button
            className={`gm-map-control-btn spin-globe-btn ${isSpinning ? 'spinning' : ''}`}
            onClick={spinTheGlobe}
            disabled={isSpinning}
            title="Descobrir um destino aleat√≥rio"
          >
            <span className="gm-map-btn-icon">{isSpinning ? '‚è≥' : 'üéØ'}</span>
            {isSpinning ? 'Descobrindo...' : 'Descobrir Destino'}
          </button>
       
        </div>
        
        {/* Barra de pesquisa integrada no header */}
        <div className="gm-map-search-container">
          <div className="gm-map-search-wrapper">
            <div className="gm-map-search-input-wrapper">
              <span className="gm-map-search-icon">üîç</span>
              <input
                type="text"
                value={searchQuery}
                onChange={handleSearchChange}
                placeholder="Pesquisar pa√≠ses, cidades, locais de interesse..."
                className="gm-map-search-input"
                maxLength={100}
              />
              {isLoading && <div className="gm-map-loading-spinner">‚è≥</div>}
            </div>
            
            {searchResults.length > 0 && (
              <div className="gm-map-search-results">
                {searchResults.map((result) => (
                  <div
                    key={result.place_id}
                    className="gm-map-search-result-item"
                    onClick={() => handleSelectLocation(result)}
                  >
                    <div className="gm-map-result-info">
                      <strong>{result.display_name}</strong>
                      <span className="gm-map-result-type">{result.type}</span>
                    </div>
                    {result.address_details && (
                      <div className="gm-map-result-details">
                        {[
                          result.address_details.city || result.address_details.town,
                          result.address_details.state || result.address_details.region,
                          result.address_details.country
                        ].filter(Boolean).join(', ')}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
            
            {searchQuery.length > 0 && !isLoading && searchResults.length === 0 && (
              <div className="gm-map-no-results">
                Nenhum resultado encontrado para "{searchQuery}"
              </div>
            )}
          </div>
        </div>
      </div>
      
    

     
      {/* Legenda moderna */}
      <div className="gm-map-legend">
        <div className="gm-map-legend-header">
          <span className="gm-map-legend-icon">üó∫Ô∏è</span>
          <span>Legenda</span>
        </div>
        <div className="gm-map-legend-items">
          <div className="gm-map-legend-item">
            <span className="gm-map-legend-marker visited">‚úì</span>
            <span>Viagens Conclu√≠das</span>
          </div>
          <div className="gm-map-legend-item">
            <span className="gm-map-legend-marker future">‚ö°</span>
            <span>Viagens Futuras</span>
          </div>
         
        </div>
      </div>

      {/* Modal de Boas-vindas */}
      {showWelcomePopup && (
        <div className="gm-map-welcome-overlay">
          <div className="gm-map-welcome-modal">
            <div className="gm-map-welcome-header">
              <h2>Bem-vindo ao Mapa Interativo</h2>
              <button className="gm-map-close-btn" onClick={closeWelcomePopup}>√ó</button>
            </div>
            <div className="gm-map-welcome-content">
              <p>Explore o mundo de forma interativa e descubra novos destinos!</p>
              <div className="gm-map-features-grid">
                <div className="gm-map-feature-item">
                  <span className="gm-map-feature-icon">‚úì</span>
                  <div>
                    <strong>Marcadores Verdes</strong>
                    <p>Viagens j√° realizadas</p>
                  </div>
                </div>
                <div className="gm-map-feature-item">
                  <span className="gm-map-feature-icon">‚ö°</span>
                  <div>
                    <strong>Marcadores Laranjas</strong>
                    <p>Viagens Futuras que est√£o a ser planeadas</p>
                  </div>
                </div>
                <div className="gm-map-feature-item">
                  <span className="gm-map-feature-icon">üîç</span>
                  <div>
                    <strong>Pesquisa Inteligente</strong>
                    <p>Encontre qualquer lugar do mundo</p>
                  </div>
                </div>
                <div className="gm-map-feature-item">
                  <span className="gm-map-feature-icon">üìä</span>
                  <div>
                    <strong>Estat√≠sticas</strong>
                    <p>Acompanhe o seu progresso de viagens</p>
                  </div>
                </div>
              </div>
            </div>
            <div className="gm-map-welcome-footer">
              <button className="gm-map-welcome-btn primary" onClick={closeWelcomePopup}>
                Comece a explorar!
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Modal de Destino Descoberto */}
      {showDestinationPopup && randomDestination && (
        <div className="gm-map-welcome-overlay">
          <div className="gm-map-welcome-modal" style={{ maxWidth: '500px' }}>
            <div className="gm-map-welcome-header">
              <h2>üéØ Destino Descoberto!</h2>
              <button className="gm-map-close-btn" onClick={closeDestinationPopup}>√ó</button>
            </div>
            <div className="gm-map-welcome-content">
              <div style={{ textAlign: 'center', marginBottom: '20px' }}>
                <div style={{ fontSize: '4rem', marginBottom: '10px' }}>üèÅ</div>
                <h3 style={{ color: '#ff6b35', marginBottom: '15px' }}>
                  A tua pr√≥xima aventura ser√° em {randomDestination.name}!
                </h3>
                <p style={{ fontSize: '1.1rem', color: '#666' }}>
                  Vamos descobrir as mem√≥rias de quem j√° esteve l√°?
                </p>
              </div>
              
              <div className="gm-map-features-grid">
                <div className="gm-map-feature-item">
                  <span className="gm-map-feature-icon">üåç</span>
                  <div>
                    <strong>Explorar {randomDestination.name}</strong>
                    <p>Descobre experi√™ncias √∫nicas de outros viajantes</p>
                  </div>
                </div>
                <div className="gm-map-feature-item">
                  <span className="gm-map-feature-icon">üìñ</span>
                  <div>
                    <strong>Hist√≥rias Reais</strong>
                    <p>L√™ sobre viagens aut√™nticas e inspiradoras</p>
                  </div>
                </div>
                <div className="gm-map-feature-item">
                  <span className="gm-map-feature-icon">üí°</span>
                  <div>
                    <strong>Dicas e Insights</strong>
                    <p>Aprende com as experi√™ncias de outros</p>
                  </div>
                </div>
                <div className="gm-map-feature-item">
                  <span className="gm-map-feature-icon">üó∫Ô∏è</span>
                  <div>
                    <strong>Planear a Tua Viagem</strong>
                    <p>Usa as informa√ß√µes para planear a tua aventura</p>
                  </div>
                </div>
              </div>
            </div>
            <div className="gm-map-welcome-footer">
              <button 
                className="gm-map-welcome-btn primary" 
                onClick={goToCountryTravels}
                style={{ backgroundColor: '#ff6b35', borderColor: '#ff6b35' }}
              >
                üîç Ver viagens em {randomDestination.name}
              </button>
              <button 
                className="gm-map-welcome-btn" 
                onClick={closeDestinationPopup}
                style={{ backgroundColor: '#6c757d', borderColor: '#6c757d', color: 'white', marginLeft: '10px' }}
              >
                Talvez depois
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Container do Mapa com m√∫ltiplas camadas */}
      <div className="gm-map-wrapper">
        <MapContainer
          center={[20, 0]}
          zoom={3}
          className="gm-map-leaflet"
          maxBounds={[[-90, -180], [90, 180]]}
          maxBoundsViscosity={1.0}
          ref={mapRef}
        >
          <LayersControl position="topright">
            <LayersControl.BaseLayer checked name="üåç Ruas">
              <TileLayer
                url={mapLayers.streets.url}
                attribution={mapLayers.streets.attribution}
                noWrap={true}
                maxZoom={19}
              />
            </LayersControl.BaseLayer>
            <LayersControl.BaseLayer name="üõ∞Ô∏è Sat√©lite">
              <TileLayer
                url={mapLayers.satellite.url}
                attribution={mapLayers.satellite.attribution}
                noWrap={true}
                maxZoom={19}
              />
            </LayersControl.BaseLayer>
            <LayersControl.BaseLayer name="üèîÔ∏è Terreno">
              <TileLayer
                url={mapLayers.terrain.url}
                attribution={mapLayers.terrain.attribution}
                noWrap={true}
                maxZoom={19}
              />
            </LayersControl.BaseLayer>
            <LayersControl.BaseLayer name="üó∫Ô∏è B√°sico">
              <TileLayer
                url={mapLayers.basic.url}
                attribution={mapLayers.basic.attribution}
                noWrap={true}
                maxZoom={19}
              />
            </LayersControl.BaseLayer>
          </LayersControl>

          {/* Marcadores de pa√≠ses e cidades visitados */}
          {filteredSets.visited.map((location, idx) => (
            <Marker
              key={`${location.city}-${location.country}-${location.user || ''}-${location.tripLink || idx}`}
              position={location.coordinates}
              icon={visitedIcon}
            >
              <Popup>
                <div className="gm-map-popup-content">
                  <h3>üèõÔ∏è {location.country} | {location.city}</h3>
                  <div className="gm-map-popup-info">
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üë§</span>
                      <span>Viajante: {location.user || 'Tu'}</span>
                    </div>
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üìç</span>
                      <span>Local: {location.city}</span>
                    </div>
                    {location.price && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üí∞</span>
                        <span>Custo: {location.price} ‚Ç¨</span>
                      </div>
                    )}
                    {location.startDate && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üìÖ</span>
                        <span>Visitado em: {location.startDate}</span>
                      </div>
                    )}
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üåç</span>
                      <span>Coordenadas: {location.coordinates[0].toFixed(4)}, {location.coordinates[1].toFixed(4)}</span>
                    </div>
                  </div>
                  <div className="gm-map-popup-actions">
                    <a href={getGoogleMapsLink(location.coordinates[0], location.coordinates[1])} target="_blank" rel="noopener noreferrer">
                      <button className="gm-map-popup-btn primary">üó∫Ô∏è Google Maps</button>
                    </a>
                    {location.tripLink && (
                      <a href={location.tripLink} target="_blank" rel="noopener noreferrer">
                        <button className="gm-map-popup-btn secondary">üìñ Ver Viagem</button>
                      </a>
                    )}
                  </div>
                </div>
              </Popup>
            </Marker>
          ))}

          {/* Marcadores de futuras viagens */}
          {filteredSets.future.map((trip, index) => (
            <Marker key={`future-${index}`} position={trip.coordinates} icon={futureIcon}>
              <Popup>
                <div className="gm-map-popup-content">
                  <h3>‚ö° {trip.label || `Viagem Futura para ${trip.city}`}</h3>
                  <div className="gm-map-popup-info">
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üåç</span>
                      <span>Pa√≠s: {trip.country}</span>
                    </div>
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üìç</span>
                      <span>Local: {trip.city}</span>
                    </div>
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üß≠</span>
                      <span>Coordenadas: {trip.coordinates[0].toFixed(4)}, {trip.coordinates[1].toFixed(4)}</span>
                    </div>
                  </div>
                  <div className="gm-map-popup-actions">
                    <a href={getGoogleMapsLink(trip.coordinates[0], trip.coordinates[1])} target="_blank" rel="noopener noreferrer">
                      <button className="gm-map-popup-btn primary">üó∫Ô∏è Google Maps</button>
                    </a>
                    <button 
                      className="gm-map-popup-btn danger"
                      onClick={() => removeFutureTrip(trip)}
                    >
                      üóëÔ∏è Remover
                    </button>
                  </div>
                </div>
              </Popup>
            </Marker>
          ))}

          {/* Marcadores de viagens de quem sigo (azuis) */}
          {mode === 'all' && filteredSets.following.map((trip, index) => (
            <Marker key={`following-${index}`} position={trip.coordinates} icon={followingIcon}>
              <Popup>
                <div className="gm-map-popup-content">
                  <h3>üë• {trip.label || `${trip.country} | ${trip.city}`}</h3>
                  <div className="gm-map-popup-info">
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üë§</span>
                      <span>Viajante: {trip.user || 'Utilizador'}</span>
                    </div>
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üåç</span>
                      <span>Pa√≠s: {trip.country}</span>
                    </div>
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üìç</span>
                      <span>Local: {trip.city}</span>
                    </div>
                    {trip.price && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üí∞</span>
                        <span>Pre√ßo: {trip.price} ‚Ç¨</span>
                      </div>
                    )}
                    {trip.startDate && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üìÖ</span>
                        <span>Data in√≠cio: {trip.startDate}</span>
                      </div>
                    )}
                    {trip.endDate && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üèÅ</span>
                        <span>Data fim: {trip.endDate}</span>
                      </div>
                    )}
                  </div>
                  <div className="gm-map-popup-actions">
                    <a href={getGoogleMapsLink(trip.coordinates[0], trip.coordinates[1])} target="_blank" rel="noopener noreferrer">
                      <button className="gm-map-popup-btn primary">üó∫Ô∏è Google Maps</button>
                    </a>
                  </div>
                </div>
              </Popup>
            </Marker>
          ))}

          {/* Marcadores de viagens p√∫blicas (amarelos) */}
          {mode === 'all' && filteredSets.public.map((trip, index) => (
            <Marker key={`public-${index}`} position={trip.coordinates} icon={publicIcon}>
              <Popup>
                <div className="gm-map-popup-content">
                  <h3>üåç {trip.label || `${trip.country} | ${trip.city}`}</h3>
                  <div className="gm-map-popup-info">
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üåç</span>
                      <span>Pa√≠s: {trip.country}</span>
                    </div>
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üìç</span>
                      <span>Local: {trip.city}</span>
                    </div>
                    {trip.price && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üí∞</span>
                        <span>Pre√ßo: {trip.price} ‚Ç¨</span>
                      </div>
                    )}
                    {trip.startDate && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üìÖ</span>
                        <span>Data in√≠cio: {trip.startDate}</span>
                      </div>
                    )}
                    {trip.endDate && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üèÅ</span>
                        <span>Data fim: {trip.endDate}</span>
                      </div>
                    )}
                  </div>
                  <div className="gm-map-popup-actions">
                    <a href={getGoogleMapsLink(trip.coordinates[0], trip.coordinates[1])} target="_blank" rel="noopener noreferrer">
                      <button className="gm-map-popup-btn primary">üó∫Ô∏è Google Maps</button>
                    </a>
                  </div>
                </div>
              </Popup>
            </Marker>
          ))}

          {/* C√≠rculo para o local selecionado (apenas quando tem radius definido) */}
          {selectedLocation && selectedLocation.radius && (
            <Circle
              center={selectedLocation.coordinates}
              radius={selectedLocation.radius}
              pathOptions={{
                color: "#3388ff",
                fillColor: "#3388ff",
                fillOpacity: 0.2,
                weight: 3,
              }}
            >
              <Popup>
                <div style={{ textAlign: 'center' }}>
                  <h3>{selectedLocation.name}</h3>
                  <p>Coordenadas: {selectedLocation.coordinates[0].toFixed(4)}, {selectedLocation.coordinates[1].toFixed(4)}</p>
                  <a href={getGoogleMapsLink(selectedLocation.coordinates[0], selectedLocation.coordinates[1])} target="_blank" rel="noopener noreferrer">
                    <button style={{ marginTop: "5px", cursor: "pointer" }}>Ver no Google Maps</button>
                  </a>
                </div>
              </Popup>
            </Circle>
          )}

          {/* Marcador do local pesquisado */}
          {searchMarker && (
            <Marker 
              position={searchMarker.coordinates} 
              icon={searchIcon}
              eventHandlers={{
                popupclose: () => {
                  // Remove o marcador quando o popup √© fechado
                  setSearchMarker(null);
                }
              }}
            >
              <Popup closeButton={false}>
                <div className="gm-map-popup-content">
                  <h3>üîç {searchMarker.name}</h3>
                  <div className="gm-map-popup-info">
                    {searchMarker.country && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üåç</span>
                        <span>Pa√≠s: {searchMarker.country}</span>
                      </div>
                    )}
                    {searchMarker.city && (
                      <div className="gm-map-info-item">
                        <span className="gm-map-info-icon">üìç</span>
                        <span>Local: {searchMarker.city}</span>
                      </div>
                    )}
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üß≠</span>
                      <span>Coordenadas: {searchMarker.coordinates[0].toFixed(4)}, {searchMarker.coordinates[1].toFixed(4)}</span>
                    </div>
                  </div>
                  <div className="gm-map-popup-actions">
                    <button
                      className="gm-map-popup-btn primary"
                      onClick={() => addFutureTripFromSearch(searchMarker)}
                    >
                      ‚ö° Adicionar Viagem
                    </button>
                    <a 
                      href={getGoogleMapsLink(searchMarker.coordinates[0], searchMarker.coordinates[1])} 
                      target="_blank" 
                      rel="noopener noreferrer"
                      style={{ display: 'block', textDecoration: 'none', flex: 1 }}
                    >
                      <button className="gm-map-popup-btn secondary">
                        üó∫Ô∏è Google Maps
                      </button>
                    </a>
                    <button
                      className="gm-map-popup-btn danger"
                      onClick={() => setSearchMarker(null)}
                    >
                      ‚ùå Fechar
                    </button>
                  </div>
                </div>
              </Popup>
            </Marker>
          )}

          {/* Marcador do boneco lan√ßador */}
          {launcherMarker && (
            <Marker 
              position={launcherMarker.coordinates} 
              icon={launcherMarker.icon}
            >
              <Popup autoOpen={true}>
                <div>
                  <h3>üßô‚Äç‚ôÇÔ∏è TESTE: Boneco Apareceu!</h3>
                  <p>Estado: {launcherMarker.phase}</p>
                  <p>Coordenadas: {launcherMarker.coordinates[0]}, {launcherMarker.coordinates[1]}</p>
                  <p>‚úÖ Se v√™s isto, o boneco est√° a funcionar!</p>
                </div>
              </Popup>
            </Marker>
          )}
          
          {/* DEBUG: Log quando launcherMarker muda */}
          {console.log('üîç LauncherMarker estado:', launcherMarker)}

          {/* Marcador da anima√ß√£o da seta (enquanto voa) - VERS√ÉO SIMPLIFICADA */}
          {arrowAnimation && (
            <Marker 
              position={arrowAnimation.coordinates} 
              icon={arrowAnimation.icon}
            >
              <Popup autoOpen={false}>
                <div style={{textAlign: 'center'}}>
                  <h3>üéØ Seta Voadora</h3>
                  <p><strong>Destino:</strong> {arrowAnimation.destination}</p>
                  {arrowAnimation.pointIndex && arrowAnimation.totalPoints && (
                    <p><strong>Progresso:</strong> {arrowAnimation.pointIndex}/{arrowAnimation.totalPoints}</p>
                  )}
                  <p>üåç A voar pelo mundo...</p>
                </div>
              </Popup>
            </Marker>
          )}
          
          {/* ‚ùå MARCADOR DE IMPACTO (X BRANCO) */}
          {impactMarker && (
            <Marker 
              position={impactMarker.coordinates} 
              icon={impactMarker.icon}
            >
              <Popup autoOpen={false} closeButton={false}>
                <div style={{textAlign: 'center', padding: '5px'}}>
                  <h4>üí• IMPACTO!</h4>
                  <p>üéØ Chegaste a {impactMarker.country}</p>
                </div>
              </Popup>
            </Marker>
          )}

          {/* DEBUG: Log quando estados mudam */}
          {console.log('üîç Estados:', { arrowAnimation, impactMarker, discoveredDestination })}

          {/* Marcador da seta "Spin the Globe" (destino final) */}
          {arrowMarker && (
            <Marker 
              position={arrowMarker.coordinates} 
              icon={arrowMarker.icon}
            >
              <Popup closeButton={false}>
                <div className="gm-map-popup-content">
                  <h3>üéØ Destino Descoberto!</h3>
                  <div className="gm-map-popup-info">
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üåç</span>
                      <span>Pa√≠s: {arrowMarker.country}</span>
                    </div>
                    <div className="gm-map-info-item">
                      <span className="gm-map-info-icon">üß≠</span>
                      <span>Coordenadas: {arrowMarker.coordinates[0].toFixed(4)}, {arrowMarker.coordinates[1].toFixed(4)}</span>
                    </div>
                  </div>
                  <div className="gm-map-popup-actions">
                    <button
                      className="gm-map-popup-btn primary"
                      onClick={goToCountryTravels}
                    >
                      üîç Ver Viagens em {arrowMarker.country}
                    </button>
                    <a 
                      href={getGoogleMapsLink(arrowMarker.coordinates[0], arrowMarker.coordinates[1])} 
                      target="_blank" 
                      rel="noopener noreferrer"
                      style={{ display: 'block', textDecoration: 'none', flex: 1 }}
                    >
                      <button className="gm-map-popup-btn secondary">
                        üó∫Ô∏è Google Maps
                      </button>
                    </a>
                    <button
                      className="gm-map-popup-btn danger"
                      onClick={closeDestinationPopup}
                    >
                      ‚ùå Fechar
                    </button>
                  </div>
                </div>
              </Popup>
            </Marker>
          )}

          {/* Popup aberto automaticamente para a viagem aleat√≥ria */}
          {randomPopup && (
            <Popup position={randomPopup.coordinates} eventHandlers={{ remove: () => setRandomPopup(null) }}>
              <div style={{ maxWidth: 260 }}>
                <h3 style={{ marginTop: 0 }}>{randomPopup.label || `${randomPopup.country} | ${randomPopup.city}`}</h3>
                {randomPopup.image && (
                  <img src={randomPopup.image} alt={randomPopup.label || randomPopup.city} style={{ width: '100%', borderRadius: 6, marginBottom: 8 }} />
                )}
                <p style={{ margin: '6px 0' }}>Pa√≠s: {randomPopup.country}</p>
                <p style={{ margin: '6px 0' }}>Local: {randomPopup.city}</p>
                {randomPopup.summary && <p style={{ margin: '6px 0' }}>{randomPopup.summary}</p>}
                {randomPopup.tripLink && (
                  <a href={randomPopup.tripLink} target="_blank" rel="noopener noreferrer">
                    <button style={{ marginTop: 6, cursor: 'pointer' }}>Ver mais</button>
                  </a>
                )}
              </div>
            </Popup>
          )}

          <MapEvents />
          <MapController selectedLocation={selectedLocation} />
        </MapContainer>

        {/* üé¨ COMPONENTES CINEMATOGR√ÅFICOS */}
        {/* üîß DEBUG BOX */}
        {showBalloon && (
          <div style={{
            position: 'fixed',
            top: '50px',
            left: '50px',
            background: 'red',
            color: 'white',
            padding: '10px',
            zIndex: 10000
          }}>
            üéà BAL√ÉO ATIVO: {String(showBalloon)}
          </div>
        )}

        {/* üé¨ OVERLAY CINEMATOGR√ÅFICO - Por cima de tudo */}
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          width: '100vw',
          height: '100vh',
          pointerEvents: showBalloon ? 'auto' : 'none',
          zIndex: 9999
        }}>
          <AnimatePresence>
          {showBalloon && (
            <BalloonComponent 
              user={user} 
              onLaunchArrow={launchArrowSequence}
            />
          )}
          
          {showArrow && arrowPosition && (
            <ArrowComponent
              startX={arrowPosition.startX}
              startY={arrowPosition.startY}
              targetX={arrowPosition.targetX}
              targetY={arrowPosition.targetY}
              onComplete={startPlaneSequence}
            />
          )}
          
          {showPlane && planePosition && (
            <PlaneComponent
              path={planePosition.path}
              onComplete={finalizeCinematicSequence}
            />
          )}
          </AnimatePresence>
        </div>

      </div>

      {/* Bot√£o de a√ß√£o flutuante */}
      {mode === 'all' && (
        <div className="gm-map-floating-action-btn">
          <button
            className="gm-map-fab-main"
            onClick={() => {
              // Considera viagens p√∫blicas e de quem sigo
              const combinedFiltered = [...(filteredSets.public || []), ...(filteredSets.following || [])];
              const combinedAll = [...(publicTrips || []), ...(followingTrips || [])];
              const basePool = combinedFiltered.length ? combinedFiltered : combinedAll;
              const pool = (basePool || []).filter(hasValidCoords);
              if (!pool.length) {
                console.warn('Sem viagens eleg√≠veis com coordenadas v√°lidas.');
                showToast('N√£o h√° viagens com coordenadas v√°lidas para explorar.', 'error');
                return;
              }
              const r = pool[Math.floor(Math.random() * pool.length)];
              const coords = [Number(r.coordinates[0]), Number(r.coordinates[1])];
              setSelectedLocation({
                coordinates: coords,
                name: `${r.city}, ${r.country}`,
                zoom: 12,
                radius: 8000,
              });
              setRandomPopup({ ...r, coordinates: coords });
            }}
          >
            <span className="gm-map-fab-icon">üé≤</span>
            <span className="gm-map-fab-text">Descobrir</span>
          </button>
        </div>
      )}
      
      {/* Toast Component */}
      <Toast
        message={toast.message}
        type={toast.type}
        show={toast.show}
        onClose={closeToast}
      />

      {/* üéØ MODAL DE DESTINO DESCOBERTO */}
      {showDestinationModal && discoveredDestination && (
        <div className="destination-modal-overlay" onClick={handleCloseDestinationModal}>
          <div className="destination-modal" onClick={(e) => e.stopPropagation()}>
            <div className="destination-modal-header">
              <h2>üéØ O teu pr√≥ximo destino √©</h2>
              <button className="destination-modal-close" onClick={handleCloseDestinationModal}>
                ‚úï
              </button>
            </div>
            
            <div className="destination-modal-content">
              <div className="destination-country">
                <span className="destination-flag">üåç</span>
                <span className="destination-name">{discoveredDestination.name}</span>
                <span className="destination-celebration">üéâ</span>
              </div>
              
              <p className="destination-question">
                Queres ver as viagens que outros fizeram l√°?
              </p>
              
              <div className="destination-modal-actions">
                <button 
                  className="destination-btn destination-btn-primary"
                  onClick={handleExploreDestination}
                >
                  üó∫Ô∏è Explorar viagens
                </button>
                <button 
                  className="destination-btn destination-btn-secondary"
                  onClick={handleCloseDestinationModal}
                >
                  ‚ú® Descobrir outro destino
                </button>
              </div>
              
              <div className="destination-info">
                <small>Descoberto por {discoveredDestination.discoveredBy}</small>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default InteractiveMap;